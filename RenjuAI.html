<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋</title>
    <style>
        body {
            margin: 0;
            background-color: #ccc;
        }

        #canvas {
            display: block;
            margin: 135px auto;
            background-color: rgb(221, 168, 21);
        }
    </style>
</head>
<button onclick="back()">悔棋</button>
<button onclick="solve()">计算</button>
<button onclick="zl()">指令</button>
<input type="text" name="zltext" id="zltext">
<br>评分:<span id ="val"></span>
<body>
    <canvas id="canvas" width="480" height="480">
    </canvas>
</body>
</html>
<script>
    var canvas = document.getElementById("canvas");
    var chessColor = ['black', 'white'];
    var mode = [
        [1, 0],
        [0, 1],
        [1, 1],
        [1, -1]
    ]
    var step = 0;
    var list=[]
    var mapChess = [];
    for (var i = 0; i < 15; i++) {
        mapChess[i] = [];
        for (var j = 0; j < 15; j++) {
            mapChess[i][j] = '';
        }
    }
    var ctx = canvas.getContext("2d");/* 获取绘制环境 */
    for(var j=0;j<2;j++){
        for (var i = 1; i < 16; i++) {
            ctx.moveTo(30 * i, 15);
            ctx.lineTo(30 * i, 465);/* 描述绘制路径 */
            ctx.moveTo(15, 30 * i);
            ctx.lineTo(465, 30 * i);
        ctx.stroke();/* 将之前所有的路径全部绘制一次 */
        }
    }
    canvas.addEventListener('click', start, false);
    function drawChess(x, y, color) {
        ctx.fillStyle = color;
        ctx.beginPath();/* 提笔 */
        ctx.arc(x, y, 13, Math.PI * 2, false);
        ctx.fill();
        ctx.stroke();
    }
    function drawPoint(x, y) {
        ctx.fillStyle = 'black';
        ctx.beginPath();/* 提笔 */
        ctx.arc(x, y, 2, Math.PI * 2, false);
        ctx.fill();
        ctx.stroke();
    }
    function start(e) {
        var color = chessColor[step % 2];
        var dx = Math.floor((e.offsetX + 15) / 30) - 1;
        var dy = Math.floor((e.offsetY + 15) / 30) - 1;
        if (dx < 0 || dx > 14 || dy < 0 || dy > 14) {
            return;
        }
        if (mapChess[dx][dy] == '') {
            drawChess((dx + 1) * 30, (dy + 1) * 30, color);
            mapChess[dx][dy] = color;
            list.push([dx,dy]);
            step++;
        }
    }
    function back(){
        if(step>0){
            ctx.clearRect((list[list.length-1][0]+1)*30-15,(list[list.length-1][1]+1)*30-15,30,30);
            ctx.beginPath()
        for(var i=0;i<2;i++){
            ctx.moveTo((list[list.length-1][0]+1)*30-15,(list[list.length-1][1]+1)*30);
            ctx.lineTo((list[list.length-1][0]+1)*30+15,(list[list.length-1][1]+1)*30);
            ctx.moveTo((list[list.length-1][0]+1)*30,(list[list.length-1][1]+1)*30-15);
            ctx.lineTo((list[list.length-1][0]+1)*30,(list[list.length-1][1]+1)*30+15);
            ctx.stroke()
        }
        mapChess[list[list.length-1][0]][list[list.length-1][1]] ='';
        list.pop();
        step--;
        }
    }
    function zl(){
        var Text=document.getElementById('zltext').value;
        alert(eval(Text))
    }
    function getType(x, y, color, mode) {
        var countBlock = 0;
        var count = 1;
        var i = 1;
        var j = 1;
        while ((x + i * mode[0]) < 15 && (y + i * mode[1]) < 15 &&
            (x + i * mode[0]) >= 0 && (y + i * mode[1]) >= 0 &&
            mapChess[x + i * mode[0]][y + i * mode[1]] != '') {
            if (mapChess[x + i * mode[0]][y + i * mode[1]] == color) {
                count++;
            } else {
                countBlock++;
                break;
            }
            i++;
        }
        while ((x - j * mode[0]) >= 0 && (y - j * mode[1]) >= 0 &&
            (x - j * mode[0]) < 15 && (y - j * mode[1]) < 15 &&
            mapChess[x - j * mode[0]][y - j * mode[1]] != '') {
            if (mapChess[x - j * mode[0]][y - j * mode[1]] == color) {
                count++;
            } else {
                countBlock++;
                break;
            }
            j++;
        }
        if (count >= 5) {
            countBlock = 0;
        } else {
            //两头都被堵住或者遇到边界的位置时这个方向下棋等于没下
            if (countBlock == 2 ||
                (x + i * mode[0]) < 0 || (y + i * mode[1]) < 0 ||
                (x + i * mode[0]) >= 15 || (y + i * mode[1]) >= 15 ||
                (x - j * mode[0]) < 0 || (y - j * mode[1]) < 0 ||
                (x - j * mode[0]) >= 15 || (y - j * mode[1]) >= 15
            ) {
                countBlock = count;
            }
        }
        return [countBlock, count];
    }
    function getPosval(x,y,color){
        var val=0
        for(var i=0;i<4;i++){
            var b=getType(x,y,'black',mode[i]);
            var w=getType(x,y,'white',mode[i]);
            if(b[1]==5){
                val+=823543;
            }
            if(w[1]==5){
                val+=823543;
            }

        }
        if(color=='black'){
            return val;
        }
        else{
            return -val;
        }
    }
    function n(x,y){
        var t=[1,-1,2,-2,3,-3]
        for(var h=0;h<4;h++){
            for(var i=0;i<6;i++){
                if(0<=x+t[i]*mode[h][0]&&x+t[i]*mode[h][0]<14&&0<=y+t[i]*mode[h][1]&&y+t[i]*mode[h][1]<14){
                    if(mapChess[x+t[i]*mode[h][0]][y+t[i]*mode[h][1]]!=''){
                        return true
                    }
                }
            }
        }
        return false
    }
    function genmove(){
        var l=[]
        for(var i=0;i<15;i++){
            for(var j=0;j<15;j++){
                if(mapChess[i][j]==0){
                    if(n(i,j)){
                        l.push(i,j)
                    }
                }
            }
        }
        return l
    }
</script>
