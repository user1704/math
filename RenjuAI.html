<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋</title>
    <style>
        body {
            margin: 0;
            background-color: #ccc;
        }

        #canvas {
            display: block;
            margin: 135px auto;
            background-color: rgb(221, 168, 21);
        }
    </style>
</head>
<button onclick="back()">悔棋</button>
<button onclick="solve()">计算</button>
<button onclick="zl()">指令</button>
<input type="text" name="zltext" id="zltext">
<br>评分:<span id ="val"></span>
<body>
    <canvas id="canvas" width="480" height="480">
    </canvas>
</body>
</html>
<script>
    var canvas = document.getElementById("canvas");
    var chessColor = ['black', 'white'];
    var mode = [
        [1, 0],
        [0, 1],
        [1, 1],
        [1, -1]
    ]
    var step = 0;
    var list=[]
    var mapChess = [];
    for (var i = 0; i < 15; i++) {
        mapChess[i] = [];
        for (var j = 0; j < 15; j++) {
            mapChess[i][j] = '';
        }
    }
    var ctx = canvas.getContext("2d");/* 获取绘制环境 */
    for(var j=0;j<2;j++){
        for (var i = 1; i < 16; i++) {
            ctx.moveTo(30 * i, 15);
            ctx.lineTo(30 * i, 465);/* 描述绘制路径 */
            ctx.moveTo(15, 30 * i);
            ctx.lineTo(465, 30 * i);
        ctx.stroke();/* 将之前所有的路径全部绘制一次 */
        }
    }
    canvas.addEventListener('click', start, false);
    function drawChess(x, y, color) {
        ctx.fillStyle = color;
        ctx.beginPath();/* 提笔 */
        ctx.arc(x, y, 13, Math.PI * 2, false);
        ctx.fill();
        ctx.stroke();
    }
    function drawPoint(x, y) {
        ctx.fillStyle = 'black';
        ctx.beginPath();/* 提笔 */
        ctx.arc(x, y, 2, Math.PI * 2, false);
        ctx.fill();
        ctx.stroke();
    }
    function start(e) {
        var color = chessColor[step % 2];
        var dx = Math.floor((e.offsetX + 15) / 30) - 1;
        var dy = Math.floor((e.offsetY + 15) / 30) - 1;
        if (dx < 0 || dx > 14 || dy < 0 || dy > 14) {
            return;
        }
        if (mapChess[dx][dy] == '') {
            xydraw(dx,dy,color)
        }
    }
    function xydraw(dx,dy,color){
        drawChess((dx + 1) * 30, (dy + 1) * 30, color);
        mapChess[dx][dy] = color;
        list.push([dx,dy]);
        step++;
    }
    function back(){
        if(step>0){
            ctx.clearRect((list[list.length-1][0]+1)*30-15,(list[list.length-1][1]+1)*30-15,30,30);
            ctx.beginPath()
        for(var i=0;i<2;i++){
            ctx.moveTo((list[list.length-1][0]+1)*30-15,(list[list.length-1][1]+1)*30);
            ctx.lineTo((list[list.length-1][0]+1)*30+15,(list[list.length-1][1]+1)*30);
            ctx.moveTo((list[list.length-1][0]+1)*30,(list[list.length-1][1]+1)*30-15);
            ctx.lineTo((list[list.length-1][0]+1)*30,(list[list.length-1][1]+1)*30+15);
            ctx.stroke()
        }
        mapChess[list[list.length-1][0]][list[list.length-1][1]] ='';
        list.pop();
        step--;
        }
    }
    function zl(){
        var Text=document.getElementById('zltext').value;
        alert(eval(Text))
    }
    function getType(x, y, color, mode) {
        var countBlock = 0;
        var count = 1;
        var countJump=0;
        var i = 1;
        var j = 1;
        while ((x + i * mode[0]) < 15 && (y + i * mode[1]) < 15 &&
            (x + i * mode[0]) >= 0 && (y + i * mode[1]) >= 0 &&
            mapChess[x + i * mode[0]][y + i * mode[1]] != '') {
            if (mapChess[x + i * mode[0]][y + i * mode[1]] == color) {
                count++;
            } else {
                countBlock++;
                break;
            }
            i++;
        }
        while ((x - j * mode[0]) >= 0 && (y - j * mode[1]) >= 0 &&
            (x - j * mode[0]) < 15 && (y - j * mode[1]) < 15 &&
            mapChess[x - j * mode[0]][y - j * mode[1]] != '') {
            if (mapChess[x - j * mode[0]][y - j * mode[1]] == color) {
                count++;
            } else {
                countBlock++;
                break;
            }
            j++;
        }
        if (count >= 5) {
            countBlock = 0;
        } else {
            if (countBlock == 2 ||
                (x + i * mode[0]) < 0 || (y + i * mode[1]) < 0 ||
                (x + i * mode[0]) >= 15 || (y + i * mode[1]) >= 15 ||
                (x - j * mode[0]) < 0 || (y - j * mode[1]) < 0 ||
                (x - j * mode[0]) >= 15 || (y - j * mode[1]) >= 15
            ) {
                countBlock = count;
            }
        }
        return [countBlock, count,countJump];
    }
    function getPosval(x,y,color){
        var val=0;
        var v5=0;
        var v4=0;
        for(var i=0;i<4;i++){
            var t=getType(x,y,color,mode[i]);
            if(color=='black'){
                if(t[1]>=6){
                    return 'ban'
                }
                else if(t[1]==5){
                    val+=823543;
                    v5+=1;
                }
                else if(t[1]==4&&t[0]==0){
                    val+=117649;
                    v4+=1;
                }
                else if(t[1]==4&&t[0]==1){
                    val+=16807;
                    v4+=1;
                }
            }
            else{
                if(t[1]>=5){
                    val+=823543;
                } 
                else if(t[1]==4&&t[0]==0){
                    val+=117649;
                    v4+=1
                }   
                else if(t[1]==4&&t[0]==1){
                    val+=16807;
                    v4+=1
                } 
            }
        }
        if(v5==0){
            if(v4>=2){
                return 'ban'
            }
        }
        return val
    }
    function n(x,y){
        var t=[1,-1,2,-2,3,-3]
        for(var h=0;h<4;h++){
            for(var i=0;i<6;i++){
                if(0<=x+t[i]*mode[h][0]&&x+t[i]*mode[h][0]<14&&0<=y+t[i]*mode[h][1]&&y+t[i]*mode[h][1]<14){
                    if(mapChess[x+t[i]*mode[h][0]][y+t[i]*mode[h][1]]!=''){
                        return true
                    }
                }
            }
        }
        return false
    }
    function genmove(){
        var l=[];
        var V5=[];
        var Xs4=[];
        var Vl4=[];
        var Vs4=[];
        var Xl3=[];
        for(var i=0;i<15;i++){
            for(var j=0;j<15;j++){
                if(mapChess[i][j]==0){
                    if(n(i,j)){
                        var t1=getPosval(i,j,chessColor[step % 2])
                        var t2=getPosval(i,j,chessColor[(step+1)%2])
                        if(t1!='ban'){
                            if(t1>=311270){
                                V5.push([t1*3+t2*2,i,j]);
                            }
                            else if(t1>=44467){
                                Vl4.push([t1*3+t2*2,i,j]);
                            }
                            else if(t1>=6352){
                                Vs4.push([t1*3+t2*2,i,j]);
                            }
                            l.push([t1*3+t2*2,i,j]);
                        }
                        if(t2!='ban'){
                            if(t2>=311270){
                                Xs4.push([t1*3+t2*2,i,j]);
                            }
                            else if(t2>=44467){
                                Xl3.push([t1*3+t2*2,i,j]);
                            }
                        }
                    }
                }
            }
        }
        if(V5.length>0){
            return V5.sort();
        }
        else if(Xs4.length>0){
            return Xs4.sort();
        }
        else if(Vl4.length>0){
            return Vl4.sort();
        }
        else if(Xl3.length>0){
            return (Xl3.concat(Vs4)).sort();
        }
        return l.sort();
    }
    function val(color){
        return 0;
    }
    function minimax(color,depth,alpha,beta){
        if(depth<=0||vl>=311270||vl<=-311270){
            return val(color);
        }
        var ml=genmove();
        for(var i=0;i<ml.length;i++){
            mapChess[ml[i][1]][ml[i][2]]=color;
            if(color=='black'){
                var vl=minimax('white',depth-1,-beta,-alpha);
            }
            else{
                var vl=minimax('black',depth-1,-beta,-alpha);
            }
            mapChess[ml[i][1]][ml[i][2]]=0;
            if(vl>alpha){
                alpha=vl;
                best=[ml[i][1],ml[i][2]];
                if(alpha>=beta){
                    break;
                }
            }
        }
        if(depth==D){return [alpha,best]};
        return alpha;
    }
    function solve(){
        var t=genmove()
        if(t.length==1){
            xydraw(t[0][1],t[0][2],chessColor[step % 2])
            document.getElementById('val').innerHTML='唯一着法'
        }
        else{
            D=1
            var t=minimax(chessColor[step % 2],D,-2178890,2178890)
            xydraw(t[1][0],t[1][1],chessColor[step % 2])
            document.getElementById('val').innerHTML=t[0]
        }
    }
</script>
